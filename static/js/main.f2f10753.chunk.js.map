{"version":3,"sources":["types/GameField.ts","hooks/useGameField.ts","FieldTile.tsx","components/WinModal.tsx","App.tsx","index.tsx"],"names":["Directions","DIMENSIONS_Y","window","outerWidth","outerHeight","DIMENSIONS_X","generateMap","cardTypes","Array","fill","map","_","i","Math","floor","cardType","splice","random","length","isSolved","isSelected","useGameField","onWin","useState","gameField","setGameField","showHint","setShowHint","couplesFound","setCouplesFound","undefined","tile1Coords","setTile1Coords","tile2Coords","setTile2Coords","existingSolution","setExistingSolution","setFieldSelected","x","y","newTile","updatedRow","oldTile","oldRow","j","updateFieldTile","canCrossTiles","x1","y1","x2","y2","paths","drawPath","direction","turns","Initial","getDirectionIncrement","newDirection","Left","Right","Up","Down","useEffect","tile1","tile2","setTimeout","updatedField","fieldRow","fieldTile","updatedSolution","getExistingSolutions","getReshuffledField","unsetSelectedTiles","coords","forEach","row","card","push","coordA","coordB","typesLeft","selectFieldTile","tile","onShowHint","FieldTile","onClick","highlighted","tileSize","min","spriteX","spriteY","getColor","selectedColor","normalColor","highlightedColor","backgroundColor","darkBorderColor","lightBorderColor","style","width","height","background","process","backgroundSize","borderTop","borderRight","borderBottom","borderLeft","cursor","WinModal","onOk","show","position","zIndex","left","top","display","alignItems","justifyContent","padding","App","setHasWon","hasWon","className","margin","maxWidth","flexDirection","caretColor","color","some","coord","key","rootElement","document","getElementById","ReactDOMClient","render"],"mappings":"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","file":"static/js/main.f2f10753.chunk.js","sourcesContent":["export type CardType = number;\r\n\r\nexport type FieldTile = {\r\n  cardType: CardType;\r\n  isSolved: boolean;\r\n  isSelected: boolean;\r\n};\r\n\r\nexport type FieldRow = Array<FieldTile>;\r\n\r\nexport type GameField = Array<FieldRow>;\r\n\r\nexport enum Directions {\r\n  Initial,\r\n  Up,\r\n  Down,\r\n  Left,\r\n  Right,\r\n}\r\n","import { useEffect, useState } from \"react\";\r\nimport { FieldTile, GameField, Directions } from \"../types/GameField\";\r\n\r\nexport const DIMENSIONS_Y = window.outerWidth > window.outerHeight ? 9 : 16;\r\nexport const DIMENSIONS_X = window.outerWidth > window.outerHeight ? 16 : 9;\r\nconst POKEMON_COUNT = 36;\r\n\r\ntype Coords = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\nconst generateMap: () => GameField = () => {\r\n  const cardTypes = new Array(DIMENSIONS_X * DIMENSIONS_Y)\r\n    .fill(null)\r\n    .map((_, i) => Math.floor(i / 4));\r\n\r\n  return new Array(DIMENSIONS_Y).fill(null).map(() =>\r\n    new Array(DIMENSIONS_X).fill(null).map(() => ({\r\n      cardType: cardTypes.splice(\r\n        Math.floor(Math.random() * cardTypes.length),\r\n        1\r\n      )[0],\r\n      isSolved: false,\r\n      isSelected: false,\r\n    }))\r\n  );\r\n};\r\n\r\nexport const useGameField = (onWin: () => void) => {\r\n  const [gameField, setGameField] = useState<GameField>(generateMap());\r\n  const [showHint, setShowHint] = useState(false);\r\n  const [couplesFound, setCouplesFound] = useState(0);\r\n\r\n  const [tile1Coords, setTile1Coords] = useState<Coords | undefined>(undefined);\r\n  const [tile2Coords, setTile2Coords] = useState<Coords | undefined>(undefined);\r\n  const [existingSolution, setExistingSolution] = useState<\r\n    Coords[] | undefined\r\n  >();\r\n\r\n  const updateFieldTile = (x: number, y: number, newTile: FieldTile) => {\r\n    const updatedRow = gameField[y].map((oldTile, i) =>\r\n      i === x ? newTile : oldTile\r\n    );\r\n    setGameField(gameField.map((oldRow, j) => (j === y ? updatedRow : oldRow)));\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param x\r\n   * @param y\r\n   * @param isSelected\r\n   */\r\n  const setFieldSelected = (x: number, y: number, isSelected: boolean) => {\r\n    updateFieldTile(x, y, {\r\n      ...gameField[y][x],\r\n      isSelected,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if the tile can be selected and updates the state of the board\r\n   *\r\n   * @param x coordinates of the field\r\n   * @param y coordinates of the field\r\n   * @returns\r\n   */\r\n  const selectFieldTile = (x: number, y: number) => {\r\n    const tile = gameField[y][x];\r\n    if (tile.isSolved || tile.isSelected) {\r\n      return;\r\n    }\r\n\r\n    if (tile1Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile1Coords({ x, y });\r\n    } else if (tile2Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile2Coords({ x, y });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Updates the field and removes selection of tiles. If `isSolved === true` then hides the tiles.\r\n   * If the resulted field does not have any solutions it will be reshuffled until one was found.\r\n   *\r\n   * @param isSolved\r\n   */\r\n  const unsetSelectedTiles = (isSolved: boolean) => {\r\n    let updatedField = gameField.map((fieldRow) =>\r\n      fieldRow.map((fieldTile) =>\r\n        fieldTile.isSelected\r\n          ? {\r\n              ...fieldTile,\r\n              isSelected: false,\r\n              isSolved,\r\n            }\r\n          : fieldTile\r\n      )\r\n    );\r\n    if (isSolved) {\r\n      setCouplesFound(couplesFound + 1);\r\n\r\n      if (couplesFound === (DIMENSIONS_X * DIMENSIONS_Y) / 2 - 1) {\r\n        updatedField = generateMap();\r\n        onWin();\r\n      }\r\n      let updatedSolution = getExistingSolutions(updatedField);\r\n\r\n      while (updatedSolution === undefined) {\r\n        updatedField = getReshuffledField(updatedField);\r\n        updatedSolution = getExistingSolutions(updatedField);\r\n      }\r\n      setExistingSolution(updatedSolution);\r\n    }\r\n\r\n    setGameField(updatedField);\r\n  };\r\n\r\n  /**\r\n   * Check if tiles can be solved by finding the shortest path between them in terms of turns to be made.\r\n   * @param tile1Coords Coordinates of the first tile on the field in the state\r\n   * @param tile2Coords Coordinates of the second tile on the field in the state\r\n   * @returns\r\n   */\r\n  const canCrossTiles = (\r\n    { x: x1, y: y1 }: Coords,\r\n    { x: x2, y: y2 }: Coords\r\n  ) => {\r\n    // Initialize paths from first tiles as infinity (or close) with extra space for path finding\r\n    const paths = new Array(DIMENSIONS_Y + 1)\r\n      .fill(null)\r\n      .map(() => new Array(DIMENSIONS_X).fill(999));\r\n    // Add outer dimension to the paths as the paths can go outside of the field\r\n    paths[-1] = new Array(DIMENSIONS_X).fill(999);\r\n\r\n    /**\r\n     * Crawls through adjacent tiles recursively and updates closest paths if possible\r\n     *\r\n     * @param direction   Initial direction of the movement. Each change of the direction increases\r\n     * @param x           coordinates of the tile in current iteration\r\n     * @param y           coordinates of the tile in current iteration\r\n     * @param turns       number of turns made to reach the tile\r\n     * @void           the function updates `paths` array and does not return anything\r\n     */\r\n    const drawPath = (\r\n      direction: Directions,\r\n      x: number,\r\n      y: number,\r\n      turns: number\r\n    ) => {\r\n      // break the function execution\r\n      if (turns > 2 || paths[y][x] < turns) {\r\n        return;\r\n      }\r\n      paths[y][x] = turns;\r\n      if (x == x2 && y == y2) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        gameField[y] &&\r\n        gameField[y][x] &&\r\n        !gameField[y][x].isSolved &&\r\n        direction !== Directions.Initial\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (paths[y2][x2] <= 2) {\r\n        return;\r\n      }\r\n\r\n      const getDirectionIncrement = (newDirection: Directions) =>\r\n        direction !== newDirection && direction !== Directions.Initial ? 1 : 0;\r\n\r\n      if (x > -1) {\r\n        drawPath(\r\n          Directions.Left,\r\n          x - 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Left)\r\n        );\r\n      }\r\n\r\n      if (x < DIMENSIONS_X) {\r\n        drawPath(\r\n          Directions.Right,\r\n          x + 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Right)\r\n        );\r\n      }\r\n\r\n      if (y > -1) {\r\n        drawPath(\r\n          Directions.Up,\r\n          x,\r\n          y - 1,\r\n          turns + getDirectionIncrement(Directions.Up)\r\n        );\r\n      }\r\n\r\n      if (y < DIMENSIONS_Y) {\r\n        drawPath(\r\n          Directions.Down,\r\n          x,\r\n          y + 1,\r\n          turns + getDirectionIncrement(Directions.Down)\r\n        );\r\n      }\r\n    };\r\n\r\n    drawPath(Directions.Initial, x1, y1, 0);\r\n\r\n    return paths[y2][x2] <= 2;\r\n  };\r\n\r\n  /**\r\n   * Check solution after both tiles have been selected by player\r\n   */\r\n  useEffect(() => {\r\n    if (tile1Coords !== undefined && tile2Coords !== undefined) {\r\n      const tile1 = gameField[tile1Coords.y][tile1Coords.x];\r\n      const tile2 = gameField[tile2Coords.y][tile2Coords.x];\r\n\r\n      const isSolved =\r\n        tile1.cardType === tile2.cardType &&\r\n        canCrossTiles(tile1Coords, tile2Coords);\r\n\r\n      setTimeout(() => {\r\n        unsetSelectedTiles(isSolved);\r\n        setTile1Coords(undefined);\r\n        setTile2Coords(undefined);\r\n        setShowHint(false);\r\n      }, 500);\r\n    }\r\n  }, [tile1Coords, tile2Coords]);\r\n\r\n  /**\r\n   * Finds all tile couples on given fields and returns first solution as an array of coordinates of two tiles.\r\n   *\r\n   * @param gameField\r\n   * @returns\r\n   */\r\n  const getExistingSolutions = (gameField: GameField) => {\r\n    for (let cardType = 0; cardType < POKEMON_COUNT; cardType++) {\r\n      const coords: Coords[] = [];\r\n      gameField.forEach((row, y) => {\r\n        row.forEach((card, x) => {\r\n          if (card.cardType === cardType && !card.isSolved) {\r\n            coords.push({ x, y });\r\n          }\r\n        });\r\n      });\r\n      for (let coordA = 0; coordA < coords.length - 1; coordA++) {\r\n        for (let coordB = coordA + 1; coordB < coords.length; coordB++) {\r\n          if (canCrossTiles(coords[coordA], coords[coordB])) {\r\n            return [coords[coordA], coords[coordB]];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n\r\n  /**\r\n   * Returns new version of the given field by reshuffling existing tiles. Used when player has no solutions available.\r\n   *\r\n   * @param gameField GameField object composed of rows and tiles inside them\r\n   * @returns\r\n   */\r\n  const getReshuffledField = (gameField: GameField) => {\r\n    const typesLeft: number[] = [];\r\n    gameField.forEach((row) =>\r\n      row.forEach((card) => {\r\n        if (!card.isSolved) {\r\n          typesLeft.push(card.cardType);\r\n        }\r\n      })\r\n    );\r\n\r\n    const newGameField = gameField.map((row) =>\r\n      row.map((card) => ({\r\n        cardType: !card.isSolved\r\n          ? typesLeft.splice(Math.floor(Math.random() * typesLeft.length), 1)[0]\r\n          : card.cardType,\r\n        isSelected: false,\r\n        isSolved: card.isSolved,\r\n      }))\r\n    );\r\n\r\n    return newGameField;\r\n  };\r\n\r\n  /**\r\n   * Initial hint preparation\r\n   */\r\n  useEffect(() => {\r\n    setExistingSolution(getExistingSolutions(gameField));\r\n  }, []);\r\n\r\n  /**\r\n   * Show two tiles that could be solved. Untoggles once player selects both of them.\r\n   */\r\n  const onShowHint = () => {\r\n    setShowHint(true);\r\n  };\r\n\r\n  return {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    couplesFound,\r\n  };\r\n};\r\n","import { DIMENSIONS_X, DIMENSIONS_Y } from \"./hooks/useGameField\";\r\nimport { FieldTile as FieldTileType } from \"./types/GameField\";\r\n\r\ntype FieldTileProps = FieldTileType & {\r\n  onClick: () => void;\r\n  highlighted: boolean;\r\n};\r\n\r\nconst FieldTile: React.FC<FieldTileProps> = ({\r\n  cardType,\r\n  isSelected,\r\n  isSolved,\r\n  onClick,\r\n  highlighted,\r\n}) => {\r\n  const tileSize = Math.min(\r\n    Math.floor(\r\n      Math.min(\r\n        (window.outerWidth - DIMENSIONS_X * 4) / DIMENSIONS_X,\r\n        window.outerHeight / DIMENSIONS_Y\r\n      )\r\n    ),\r\n    60\r\n  );\r\n  const spriteX = Math.floor(cardType % 6) * tileSize;\r\n  const spriteY = Math.floor(cardType / 6) * tileSize;\r\n\r\n  const getColor = (\r\n    selectedColor: string,\r\n    normalColor: string,\r\n    highlightedColor: string\r\n  ) => {\r\n    if (isSolved) {\r\n      return \"transparent\";\r\n    }\r\n    if (isSelected) {\r\n      return selectedColor;\r\n    }\r\n    if (highlighted) {\r\n      return highlightedColor;\r\n    }\r\n\r\n    return normalColor;\r\n  };\r\n\r\n  const backgroundColor = getColor(\"#B5DDE5\", \"#FFFFDB\", \"red\");\r\n  const darkBorderColor = getColor(\"#566F81\", \"#817C56\", \"red\");\r\n  const lightBorderColor = getColor(\"#D2F7FF\", \"#E9E3B9\", \"red\");\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width: tileSize + \"px\",\r\n        height: tileSize + \"px\",\r\n        background: isSolved\r\n          ? undefined\r\n          : `url(${process.env.PUBLIC_URL}/sprites.png) ${spriteX}px ${spriteY}px`,\r\n        backgroundColor,\r\n        backgroundSize: `${360 * (tileSize / 60)}px`,\r\n        borderTop: \"2px solid \" + darkBorderColor,\r\n        borderRight: \"2px solid \" + darkBorderColor,\r\n        borderBottom: \"2px solid \" + lightBorderColor,\r\n        borderLeft: \"2px solid \" + lightBorderColor,\r\n        cursor: isSolved ? \"default\" : \"pointer\",\r\n      }}\r\n      onClick={() => onClick()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default FieldTile;\r\n","type WinModalProps = {\r\n  onOk: () => void;\r\n  show: boolean;\r\n};\r\n\r\nconst WinModal: React.FC<WinModalProps> = ({ onOk, show }) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        backgroundColor: \"rgba(0, 0, 0, .4)\",\r\n        position: \"absolute\",\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n        zIndex: 10,\r\n        left: 0,\r\n        top: 0,\r\n        display: show ? \"flex\" : \"none\",\r\n        alignItems: \"center\",\r\n        justifyContent: \"center\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          backgroundColor: \"#FFF\",\r\n          padding: \"16px\",\r\n        }}\r\n      >\r\n        <h2>Congratulations!</h2>\r\n        <p>\r\n          There are no further levels at this point but you can replay the first\r\n          level again :)\r\n        </p>\r\n        <button onClick={onOk}>Great</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WinModal;\r\n","import \"./styles.css\";\r\nimport FieldTile from \"./FieldTile\";\r\nimport { useGameField } from \"./hooks/useGameField\";\r\nimport { useState } from \"react\";\r\nimport WinModal from \"./components/WinModal\";\r\n\r\nexport default function App() {\r\n  const {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    couplesFound,\r\n  } = useGameField(() => {\r\n    setHasWon(true);\r\n  });\r\n\r\n  const [hasWon, setHasWon] = useState(false);\r\n\r\n  return (\r\n    <div\r\n      className=\"App\"\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        height: \"100vh\",\r\n        margin: \"0 auto\",\r\n        maxWidth: \"1024px\",\r\n        flexDirection: \"column\",\r\n        caretColor: \"transparent\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          width: \"100%\",\r\n          display: \"flex\",\r\n          alignItems: \"center\",\r\n          justifyContent: \"space-between\",\r\n        }}\r\n      >\r\n        <h1 style={{ color: \"white\" }}>PaoPao {couplesFound}/72</h1>\r\n        <button onClick={onShowHint}>Show hint</button>\r\n      </div>\r\n      <div>\r\n        {gameField.map((row, y) => (\r\n          <div\r\n            key={`row-${y}`}\r\n            style={{\r\n              display: \"flex\",\r\n            }}\r\n          >\r\n            {row.map((card, x) => (\r\n              <FieldTile\r\n                highlighted={\r\n                  showHint && existingSolution\r\n                    ? existingSolution?.some(\r\n                        (coord) => coord.x === x && coord.y === y\r\n                      )\r\n                    : false\r\n                }\r\n                {...card}\r\n                key={`card-${x}-${y}-${card.cardType}`}\r\n                onClick={() => selectFieldTile(x, y)}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n      <WinModal show={hasWon} onOk={() => setHasWon(false)} />\r\n    </div>\r\n  );\r\n}\r\n","import { StrictMode } from \"react\";\r\nimport * as ReactDOMClient from \"react-dom/client\";\r\n\r\nimport App from \"./App\";\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nconst root = ReactDOMClient.createRoot(rootElement);\r\n\r\nroot.render(\r\n  <StrictMode>\r\n    <App />\r\n  </StrictMode>\r\n);\r\n"],"sourceRoot":""}
{"version":3,"sources":["types/GameField.ts","FieldTile.tsx","hooks/useGameField.ts","components/WinModal.tsx","App.tsx","index.tsx"],"names":["Directions","FieldTile","cardType","isSelected","isSolved","onClick","highlighted","spriteX","Math","floor","spriteY","getColor","selectedColor","normalColor","highlightedColor","backgroundColor","darkBorderColor","lightBorderColor","style","width","height","background","undefined","process","borderTop","borderRight","borderBottom","borderLeft","cursor","DIMENSIONS_Y","window","outerWidth","outerHeight","DIMENSIONS_X","generateMap","cardTypes","Array","fill","map","_","i","splice","random","length","useGameField","onWin","useState","gameField","setGameField","showHint","setShowHint","couplesFound","setCouplesFound","tile1Coords","setTile1Coords","tile2Coords","setTile2Coords","existingSolution","setExistingSolution","setFieldSelected","x","y","newTile","updatedRow","oldTile","oldRow","j","updateFieldTile","canCrossTiles","x1","y1","x2","y2","paths","drawPath","direction","turns","Initial","getDirectionIncrement","newDirection","Left","Right","Up","Down","useEffect","tile1","tile2","setTimeout","updatedField","fieldRow","fieldTile","updatedSolution","getExistingSolutions","getReshuffledField","unsetSelectedTiles","coords","forEach","row","card","push","coordA","coordB","typesLeft","selectFieldTile","tile","onShowHint","WinModal","onOk","show","position","zIndex","left","top","display","alignItems","justifyContent","padding","App","setHasWon","hasWon","className","margin","maxWidth","flexDirection","caretColor","some","coord","key","rootElement","document","getElementById","ReactDOMClient","render"],"mappings":"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","file":"static/js/main.fba90808.chunk.js","sourcesContent":["export type CardType = number;\r\n\r\nexport type FieldTile = {\r\n  cardType: CardType;\r\n  isSolved: boolean;\r\n  isSelected: boolean;\r\n};\r\n\r\nexport type FieldRow = Array<FieldTile>;\r\n\r\nexport type GameField = Array<FieldRow>;\r\n\r\nexport enum Directions {\r\n  Initial,\r\n  Up,\r\n  Down,\r\n  Left,\r\n  Right,\r\n}\r\n","import { FieldTile as FieldTileType } from \"./types/GameField\";\r\n\r\ntype FieldTileProps = FieldTileType & {\r\n  onClick: () => void;\r\n  highlighted: boolean;\r\n};\r\n\r\nconst FieldTile: React.FC<FieldTileProps> = ({\r\n  cardType,\r\n  isSelected,\r\n  isSolved,\r\n  onClick,\r\n  highlighted,\r\n}) => {\r\n  const spriteX = Math.floor(cardType % 6) * 60;\r\n  const spriteY = Math.floor(cardType / 6) * 60;\r\n\r\n  const getColor = (\r\n    selectedColor: string,\r\n    normalColor: string,\r\n    highlightedColor: string\r\n  ) => {\r\n    if (isSolved) {\r\n      return \"transparent\";\r\n    }\r\n    if (isSelected) {\r\n      return selectedColor;\r\n    }\r\n    if (highlighted) {\r\n      return highlightedColor;\r\n    }\r\n\r\n    return normalColor;\r\n  };\r\n\r\n  const backgroundColor = getColor(\"#B5DDE5\", \"#FFFFDB\", \"red\");\r\n  const darkBorderColor = getColor(\"#566F81\", \"#817C56\", \"red\");\r\n  const lightBorderColor = getColor(\"#D2F7FF\", \"#E9E3B9\", \"red\");\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width: \"60px\",\r\n        height: \"60px\",\r\n        background: isSolved\r\n          ? undefined\r\n          : `url(${process.env.PUBLIC_URL}/sprites.png) ${spriteX}px ${spriteY}px`,\r\n        backgroundColor,\r\n        borderTop: \"2px solid \" + darkBorderColor,\r\n        borderRight: \"2px solid \" + darkBorderColor,\r\n        borderBottom: \"2px solid \" + lightBorderColor,\r\n        borderLeft: \"2px solid \" + lightBorderColor,\r\n        cursor: isSolved ? \"default\" : \"pointer\",\r\n      }}\r\n      onClick={() => onClick()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default FieldTile;\r\n","import { useEffect, useState } from \"react\";\r\nimport { FieldTile, GameField, Directions } from \"../types/GameField\";\r\n\r\nconst DIMENSIONS_Y = window.outerWidth > window.outerHeight ? 9 : 16;\r\nconst DIMENSIONS_X = window.outerWidth > window.outerHeight ? 16 : 9;\r\nconst POKEMON_COUNT = 36;\r\n\r\ntype Coords = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\nconst generateMap: () => GameField = () => {\r\n  const cardTypes = new Array(DIMENSIONS_X * DIMENSIONS_Y)\r\n    .fill(null)\r\n    .map((_, i) => Math.floor(i / 4));\r\n\r\n  return new Array(DIMENSIONS_Y).fill(null).map(() =>\r\n    new Array(DIMENSIONS_X).fill(null).map(() => ({\r\n      cardType: cardTypes.splice(\r\n        Math.floor(Math.random() * cardTypes.length),\r\n        1\r\n      )[0],\r\n      isSolved: false,\r\n      isSelected: false,\r\n    }))\r\n  );\r\n};\r\n\r\nexport const useGameField = (onWin: () => void) => {\r\n  const [gameField, setGameField] = useState<GameField>(generateMap());\r\n  const [showHint, setShowHint] = useState(false);\r\n  const [couplesFound, setCouplesFound] = useState(0);\r\n\r\n  const [tile1Coords, setTile1Coords] = useState<Coords | undefined>(undefined);\r\n  const [tile2Coords, setTile2Coords] = useState<Coords | undefined>(undefined);\r\n  const [existingSolution, setExistingSolution] = useState<\r\n    Coords[] | undefined\r\n  >();\r\n\r\n  const updateFieldTile = (x: number, y: number, newTile: FieldTile) => {\r\n    const updatedRow = gameField[y].map((oldTile, i) =>\r\n      i === x ? newTile : oldTile\r\n    );\r\n    setGameField(gameField.map((oldRow, j) => (j === y ? updatedRow : oldRow)));\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param x\r\n   * @param y\r\n   * @param isSelected\r\n   */\r\n  const setFieldSelected = (x: number, y: number, isSelected: boolean) => {\r\n    updateFieldTile(x, y, {\r\n      ...gameField[y][x],\r\n      isSelected,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if the tile can be selected and updates the state of the board\r\n   *\r\n   * @param x coordinates of the field\r\n   * @param y coordinates of the field\r\n   * @returns\r\n   */\r\n  const selectFieldTile = (x: number, y: number) => {\r\n    const tile = gameField[y][x];\r\n    if (tile.isSolved || tile.isSelected) {\r\n      return;\r\n    }\r\n\r\n    if (tile1Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile1Coords({ x, y });\r\n    } else if (tile2Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile2Coords({ x, y });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Updates the field and removes selection of tiles. If `isSolved === true` then hides the tiles.\r\n   * If the resulted field does not have any solutions it will be reshuffled until one was found.\r\n   *\r\n   * @param isSolved\r\n   */\r\n  const unsetSelectedTiles = (isSolved: boolean) => {\r\n    let updatedField = gameField.map((fieldRow) =>\r\n      fieldRow.map((fieldTile) =>\r\n        fieldTile.isSelected\r\n          ? {\r\n              ...fieldTile,\r\n              isSelected: false,\r\n              isSolved,\r\n            }\r\n          : fieldTile\r\n      )\r\n    );\r\n    if (isSolved) {\r\n      setCouplesFound(couplesFound + 1);\r\n\r\n      if (couplesFound === (DIMENSIONS_X * DIMENSIONS_Y) / 2 - 1) {\r\n        updatedField = generateMap();\r\n        onWin();\r\n      }\r\n      let updatedSolution = getExistingSolutions(updatedField);\r\n\r\n      while (updatedSolution === undefined) {\r\n        updatedField = getReshuffledField(updatedField);\r\n        updatedSolution = getExistingSolutions(updatedField);\r\n      }\r\n      setExistingSolution(updatedSolution);\r\n    }\r\n\r\n    setGameField(updatedField);\r\n  };\r\n\r\n  /**\r\n   * Check if tiles can be solved by finding the shortest path between them in terms of turns to be made.\r\n   * @param tile1Coords Coordinates of the first tile on the field in the state\r\n   * @param tile2Coords Coordinates of the second tile on the field in the state\r\n   * @returns\r\n   */\r\n  const canCrossTiles = (\r\n    { x: x1, y: y1 }: Coords,\r\n    { x: x2, y: y2 }: Coords\r\n  ) => {\r\n    // Initialize paths from first tiles as infinity (or close) with extra space for path finding\r\n    const paths = new Array(DIMENSIONS_Y + 1)\r\n      .fill(null)\r\n      .map(() => new Array(DIMENSIONS_X).fill(999));\r\n    // Add outer dimension to the paths as the paths can go outside of the field\r\n    paths[-1] = new Array(DIMENSIONS_X).fill(999);\r\n\r\n    /**\r\n     * Crawls through adjacent tiles recursively and updates closest paths if possible\r\n     *\r\n     * @param direction   Initial direction of the movement. Each change of the direction increases\r\n     * @param x           coordinates of the tile in current iteration\r\n     * @param y           coordinates of the tile in current iteration\r\n     * @param turns       number of turns made to reach the tile\r\n     * @void           the function updates `paths` array and does not return anything\r\n     */\r\n    const drawPath = (\r\n      direction: Directions,\r\n      x: number,\r\n      y: number,\r\n      turns: number\r\n    ) => {\r\n      // break the function execution\r\n      if (turns > 2 || paths[y][x] < turns) {\r\n        return;\r\n      }\r\n      paths[y][x] = turns;\r\n      if (x == x2 && y == y2) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        gameField[y] &&\r\n        gameField[y][x] &&\r\n        !gameField[y][x].isSolved &&\r\n        direction !== Directions.Initial\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (paths[y2][x2] <= 2) {\r\n        return;\r\n      }\r\n\r\n      const getDirectionIncrement = (newDirection: Directions) =>\r\n        direction !== newDirection && direction !== Directions.Initial ? 1 : 0;\r\n\r\n      if (x > -1) {\r\n        drawPath(\r\n          Directions.Left,\r\n          x - 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Left)\r\n        );\r\n      }\r\n\r\n      if (x < DIMENSIONS_X) {\r\n        drawPath(\r\n          Directions.Right,\r\n          x + 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Right)\r\n        );\r\n      }\r\n\r\n      if (y > -1) {\r\n        drawPath(\r\n          Directions.Up,\r\n          x,\r\n          y - 1,\r\n          turns + getDirectionIncrement(Directions.Up)\r\n        );\r\n      }\r\n\r\n      if (y < DIMENSIONS_Y) {\r\n        drawPath(\r\n          Directions.Down,\r\n          x,\r\n          y + 1,\r\n          turns + getDirectionIncrement(Directions.Down)\r\n        );\r\n      }\r\n    };\r\n\r\n    drawPath(Directions.Initial, x1, y1, 0);\r\n\r\n    return paths[y2][x2] <= 2;\r\n  };\r\n\r\n  /**\r\n   * Check solution after both tiles have been selected by player\r\n   */\r\n  useEffect(() => {\r\n    if (tile1Coords !== undefined && tile2Coords !== undefined) {\r\n      const tile1 = gameField[tile1Coords.y][tile1Coords.x];\r\n      const tile2 = gameField[tile2Coords.y][tile2Coords.x];\r\n\r\n      const isSolved =\r\n        tile1.cardType === tile2.cardType &&\r\n        canCrossTiles(tile1Coords, tile2Coords);\r\n\r\n      setTimeout(() => {\r\n        unsetSelectedTiles(isSolved);\r\n        setTile1Coords(undefined);\r\n        setTile2Coords(undefined);\r\n        setShowHint(false);\r\n      }, 500);\r\n    }\r\n  }, [tile1Coords, tile2Coords]);\r\n\r\n  /**\r\n   * Finds all tile couples on given fields and returns first solution as an array of coordinates of two tiles.\r\n   *\r\n   * @param gameField\r\n   * @returns\r\n   */\r\n  const getExistingSolutions = (gameField: GameField) => {\r\n    for (let cardType = 0; cardType < POKEMON_COUNT; cardType++) {\r\n      const coords: Coords[] = [];\r\n      gameField.forEach((row, y) => {\r\n        row.forEach((card, x) => {\r\n          if (card.cardType === cardType && !card.isSolved) {\r\n            coords.push({ x, y });\r\n          }\r\n        });\r\n      });\r\n      for (let coordA = 0; coordA < coords.length - 1; coordA++) {\r\n        for (let coordB = coordA + 1; coordB < coords.length; coordB++) {\r\n          if (canCrossTiles(coords[coordA], coords[coordB])) {\r\n            return [coords[coordA], coords[coordB]];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n\r\n  /**\r\n   * Returns new version of the given field by reshuffling existing tiles. Used when player has no solutions available.\r\n   *\r\n   * @param gameField GameField object composed of rows and tiles inside them\r\n   * @returns\r\n   */\r\n  const getReshuffledField = (gameField: GameField) => {\r\n    const typesLeft: number[] = [];\r\n    gameField.forEach((row) =>\r\n      row.forEach((card) => {\r\n        if (!card.isSolved) {\r\n          typesLeft.push(card.cardType);\r\n        }\r\n      })\r\n    );\r\n\r\n    const newGameField = gameField.map((row) =>\r\n      row.map((card) => ({\r\n        cardType: !card.isSolved\r\n          ? typesLeft.splice(Math.floor(Math.random() * typesLeft.length), 1)[0]\r\n          : card.cardType,\r\n        isSelected: false,\r\n        isSolved: card.isSolved,\r\n      }))\r\n    );\r\n\r\n    return newGameField;\r\n  };\r\n\r\n  /**\r\n   * Initial hint preparation\r\n   */\r\n  useEffect(() => {\r\n    setExistingSolution(getExistingSolutions(gameField));\r\n  }, []);\r\n\r\n  /**\r\n   * Show two tiles that could be solved. Untoggles once player selects both of them.\r\n   */\r\n  const onShowHint = () => {\r\n    setShowHint(true);\r\n  };\r\n\r\n  return {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    couplesFound,\r\n  };\r\n};\r\n","type WinModalProps = {\r\n  onOk: () => void;\r\n  show: boolean;\r\n};\r\n\r\nconst WinModal: React.FC<WinModalProps> = ({ onOk, show }) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        backgroundColor: \"rgba(0, 0, 0, .4)\",\r\n        position: \"absolute\",\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n        zIndex: 10,\r\n        left: 0,\r\n        top: 0,\r\n        display: show ? \"flex\" : \"none\",\r\n        alignItems: \"center\",\r\n        justifyContent: \"center\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          backgroundColor: \"#FFF\",\r\n          padding: \"16px\",\r\n        }}\r\n      >\r\n        <h2>Congratulations!</h2>\r\n        <p>\r\n          There are no further levels at this point but you can replay the first\r\n          level again :)\r\n        </p>\r\n        <button onClick={onOk}>Great</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WinModal;\r\n","import \"./styles.css\";\r\nimport FieldTile from \"./FieldTile\";\r\nimport { useGameField } from \"./hooks/useGameField\";\r\nimport { useState } from \"react\";\r\nimport WinModal from \"./components/WinModal\";\r\n\r\nexport default function App() {\r\n  const {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    couplesFound,\r\n  } = useGameField(() => {\r\n    setHasWon(true);\r\n  });\r\n\r\n  const [hasWon, setHasWon] = useState(false);\r\n\r\n  return (\r\n    <div\r\n      className=\"App\"\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        height: \"100vh\",\r\n        margin: \"0 auto\",\r\n        maxWidth: \"1024px\",\r\n        flexDirection: \"column\",\r\n        caretColor: \"transparent\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          width: \"100%\",\r\n          display: \"flex\",\r\n          alignItems: \"center\",\r\n          justifyContent: \"space-between\",\r\n        }}\r\n      >\r\n        <h1>PaoPao {couplesFound}/72</h1>\r\n        <button onClick={onShowHint}>Show hint</button>\r\n      </div>\r\n      <div>\r\n        {gameField.map((row, y) => (\r\n          <div\r\n            key={`row-${y}`}\r\n            style={{\r\n              display: \"flex\",\r\n            }}\r\n          >\r\n            {row.map((card, x) => (\r\n              <FieldTile\r\n                highlighted={\r\n                  showHint && existingSolution\r\n                    ? existingSolution?.some(\r\n                        (coord) => coord.x === x && coord.y === y\r\n                      )\r\n                    : false\r\n                }\r\n                {...card}\r\n                key={`card-${x}-${y}-${card.cardType}`}\r\n                onClick={() => selectFieldTile(x, y)}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n      <WinModal show={hasWon} onOk={() => setHasWon(false)} />\r\n    </div>\r\n  );\r\n}\r\n","import { StrictMode } from \"react\";\r\nimport * as ReactDOMClient from \"react-dom/client\";\r\n\r\nimport App from \"./App\";\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nconst root = ReactDOMClient.createRoot(rootElement);\r\n\r\nroot.render(\r\n  <StrictMode>\r\n    <App />\r\n  </StrictMode>\r\n);\r\n"],"sourceRoot":""}
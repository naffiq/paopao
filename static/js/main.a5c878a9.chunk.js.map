{"version":3,"sources":["serviceWorkerRegistration.ts","types/GameField.ts","hooks/useGameField.ts","components/FieldTile.tsx","components/WinModal.tsx","App.tsx","index.tsx"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","Directions","DIMENSIONS_Y","outerWidth","outerHeight","DIMENSIONS_X","FIELD_STORAGE_KEY","generateMap","cardTypes","Array","fill","map","_","i","Math","floor","cardType","splice","random","length","isSolved","isSelected","storedFieldString","localStorage","getItem","initialField","JSON","parse","useGameField","onWin","useState","gameField","setGameField","showHint","setShowHint","count","forEach","row","card","countSolvedTiles","couplesFound","setCouplesFound","undefined","tile1Coords","setTile1Coords","tile2Coords","setTile2Coords","existingSolution","setExistingSolution","setFieldSelected","x","y","newTile","updatedRow","oldTile","oldRow","j","updateFieldTile","canCrossTiles","x1","y1","x2","y2","paths","drawPath","direction","turns","Initial","getDirectionIncrement","newDirection","Left","Right","Up","Down","useEffect","tile1","tile2","setTimeout","updatedField","fieldRow","fieldTile","updatedSolution","getExistingSolutions","getReshuffledField","setItem","stringify","unsetSelectedTiles","coords","push","coordA","coordB","typesLeft","selectFieldTile","tile","onShowHint","FieldTile","onClick","highlighted","tileSize","min","innerWidth","innerHeight","spriteX","spriteY","getColor","selectedColor","normalColor","highlightedColor","backgroundColor","darkBorderColor","lightBorderColor","style","width","height","backgroundImage","process","backgroundPosition","backgroundSize","borderTop","borderRight","borderBottom","borderLeft","cursor","WinModal","onOk","show","position","zIndex","left","top","display","alignItems","justifyContent","padding","App","setHasWon","hasWon","className","margin","maxWidth","flexDirection","caretColor","color","some","coord","key","rootElement","document","getElementById","ReactDOMClient","render","URL","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.a5c878a9.chunk.js","sourcesContent":["const isLocalhost = Boolean(\r\n  window.location.hostname === \"localhost\" ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === \"[::1]\" ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config?: any) {\r\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener(\"load\", () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            \"This web app is being served cache-first by a service \" +\r\n              \"worker. To learn more, visit https://cra.link/PWA\"\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: any, config: any) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === \"installed\") {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                \"New content is available and will be used when all \" +\r\n                  \"tabs for this page are closed. See https://cra.link/PWA.\"\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log(\"Content is cached for offline use.\");\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error(\"Error during service worker registration:\", error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: any, config: any) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { \"Service-Worker\": \"script\" },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get(\"content-type\");\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        \"No internet connection found. App is running in offline mode.\"\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if (\"serviceWorker\" in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","export type CardType = number;\r\n\r\nexport type FieldTile = {\r\n  cardType: CardType;\r\n  isSolved: boolean;\r\n  isSelected: boolean;\r\n};\r\n\r\nexport type FieldRow = Array<FieldTile>;\r\n\r\nexport type GameField = Array<FieldRow>;\r\n\r\nexport enum Directions {\r\n  Initial,\r\n  Up,\r\n  Down,\r\n  Left,\r\n  Right,\r\n}\r\n","import { useEffect, useState } from \"react\";\r\nimport { FieldTile, GameField, Directions } from \"../types/GameField\";\r\n\r\nexport const DIMENSIONS_Y = window.outerWidth > window.outerHeight ? 9 : 16;\r\nexport const DIMENSIONS_X = window.outerWidth > window.outerHeight ? 16 : 9;\r\nconst POKEMON_COUNT = 36;\r\nconst FIELD_STORAGE_KEY = \"paopao-field\";\r\n\r\ntype Coords = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\nconst generateMap: () => GameField = () => {\r\n  const cardTypes = new Array(DIMENSIONS_X * DIMENSIONS_Y)\r\n    .fill(null)\r\n    .map((_, i) => Math.floor(i / 4));\r\n\r\n  return new Array(DIMENSIONS_Y).fill(null).map(() =>\r\n    new Array(DIMENSIONS_X).fill(null).map(() => ({\r\n      cardType: cardTypes.splice(\r\n        Math.floor(Math.random() * cardTypes.length),\r\n        1\r\n      )[0],\r\n      isSolved: false,\r\n      isSelected: false,\r\n    }))\r\n  );\r\n};\r\n\r\nconst storedFieldString = localStorage.getItem(FIELD_STORAGE_KEY);\r\nconst initialField =\r\n  storedFieldString !== null ? JSON.parse(storedFieldString) : generateMap();\r\n\r\nconst countSolvedTiles = (gameField: GameField) => {\r\n  let count = 0;\r\n  gameField.forEach((row) =>\r\n    row.forEach((card) => (count += card.isSolved ? 1 : 0))\r\n  );\r\n  return count / 2;\r\n};\r\n\r\nexport const useGameField = (onWin: () => void) => {\r\n  const [gameField, setGameField] = useState<GameField>(initialField);\r\n  const [showHint, setShowHint] = useState(false);\r\n  const [couplesFound, setCouplesFound] = useState(\r\n    countSolvedTiles(initialField)\r\n  );\r\n\r\n  const [tile1Coords, setTile1Coords] = useState<Coords | undefined>(undefined);\r\n  const [tile2Coords, setTile2Coords] = useState<Coords | undefined>(undefined);\r\n  const [existingSolution, setExistingSolution] = useState<\r\n    Coords[] | undefined\r\n  >();\r\n\r\n  const updateFieldTile = (x: number, y: number, newTile: FieldTile) => {\r\n    const updatedRow = gameField[y].map((oldTile, i) =>\r\n      i === x ? newTile : oldTile\r\n    );\r\n    setGameField(gameField.map((oldRow, j) => (j === y ? updatedRow : oldRow)));\r\n  };\r\n\r\n  /**\r\n   *\r\n   * @param x\r\n   * @param y\r\n   * @param isSelected\r\n   */\r\n  const setFieldSelected = (x: number, y: number, isSelected: boolean) => {\r\n    updateFieldTile(x, y, {\r\n      ...gameField[y][x],\r\n      isSelected,\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if the tile can be selected and updates the state of the board\r\n   *\r\n   * @param x coordinates of the field\r\n   * @param y coordinates of the field\r\n   * @returns\r\n   */\r\n  const selectFieldTile = (x: number, y: number) => {\r\n    const tile = gameField[y][x];\r\n    if (tile.isSolved || tile.isSelected) {\r\n      return;\r\n    }\r\n\r\n    if (tile1Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile1Coords({ x, y });\r\n    } else if (tile2Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile2Coords({ x, y });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Updates the field and removes selection of tiles. If `isSolved === true` then hides the tiles.\r\n   * If the resulted field does not have any solutions it will be reshuffled until one was found.\r\n   *\r\n   * @param isSolved\r\n   */\r\n  const unsetSelectedTiles = (isSolved: boolean) => {\r\n    let updatedField = gameField.map((fieldRow) =>\r\n      fieldRow.map((fieldTile) =>\r\n        fieldTile.isSelected\r\n          ? {\r\n              ...fieldTile,\r\n              isSelected: false,\r\n              isSolved,\r\n            }\r\n          : fieldTile\r\n      )\r\n    );\r\n    if (isSolved) {\r\n      setCouplesFound(couplesFound + 1);\r\n\r\n      if (couplesFound === (DIMENSIONS_X * DIMENSIONS_Y) / 2 - 1) {\r\n        updatedField = generateMap();\r\n        onWin();\r\n      }\r\n      let updatedSolution = getExistingSolutions(updatedField);\r\n\r\n      while (updatedSolution === undefined) {\r\n        updatedField = getReshuffledField(updatedField);\r\n        updatedSolution = getExistingSolutions(updatedField);\r\n      }\r\n      setExistingSolution(updatedSolution);\r\n    }\r\n\r\n    setGameField(updatedField);\r\n    localStorage.setItem(FIELD_STORAGE_KEY, JSON.stringify(updatedField));\r\n  };\r\n\r\n  /**\r\n   * Check if tiles can be solved by finding the shortest path between them in terms of turns to be made.\r\n   * @param tile1Coords Coordinates of the first tile on the field in the state\r\n   * @param tile2Coords Coordinates of the second tile on the field in the state\r\n   * @returns\r\n   */\r\n  const canCrossTiles = (\r\n    { x: x1, y: y1 }: Coords,\r\n    { x: x2, y: y2 }: Coords\r\n  ) => {\r\n    // Initialize paths from first tiles as infinity (or close) with extra space for path finding\r\n    const paths = new Array(DIMENSIONS_Y + 1)\r\n      .fill(null)\r\n      .map(() => new Array(DIMENSIONS_X).fill(999));\r\n    // Add outer dimension to the paths as the paths can go outside of the field\r\n    paths[-1] = new Array(DIMENSIONS_X).fill(999);\r\n\r\n    /**\r\n     * Crawls through adjacent tiles recursively and updates closest paths if possible\r\n     *\r\n     * @param direction   Initial direction of the movement. Each change of the direction increases\r\n     * @param x           coordinates of the tile in current iteration\r\n     * @param y           coordinates of the tile in current iteration\r\n     * @param turns       number of turns made to reach the tile\r\n     * @void           the function updates `paths` array and does not return anything\r\n     */\r\n    const drawPath = (\r\n      direction: Directions,\r\n      x: number,\r\n      y: number,\r\n      turns: number\r\n    ) => {\r\n      // break the function execution\r\n      if (turns > 2 || paths[y][x] < turns) {\r\n        return;\r\n      }\r\n      paths[y][x] = turns;\r\n      if (x == x2 && y == y2) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        gameField[y] &&\r\n        gameField[y][x] &&\r\n        !gameField[y][x].isSolved &&\r\n        direction !== Directions.Initial\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (paths[y2][x2] <= 2) {\r\n        return;\r\n      }\r\n\r\n      const getDirectionIncrement = (newDirection: Directions) =>\r\n        direction !== newDirection && direction !== Directions.Initial ? 1 : 0;\r\n\r\n      if (x > -1) {\r\n        drawPath(\r\n          Directions.Left,\r\n          x - 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Left)\r\n        );\r\n      }\r\n\r\n      if (x < DIMENSIONS_X) {\r\n        drawPath(\r\n          Directions.Right,\r\n          x + 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Right)\r\n        );\r\n      }\r\n\r\n      if (y > -1) {\r\n        drawPath(\r\n          Directions.Up,\r\n          x,\r\n          y - 1,\r\n          turns + getDirectionIncrement(Directions.Up)\r\n        );\r\n      }\r\n\r\n      if (y < DIMENSIONS_Y) {\r\n        drawPath(\r\n          Directions.Down,\r\n          x,\r\n          y + 1,\r\n          turns + getDirectionIncrement(Directions.Down)\r\n        );\r\n      }\r\n    };\r\n\r\n    drawPath(Directions.Initial, x1, y1, 0);\r\n\r\n    return paths[y2][x2] <= 2;\r\n  };\r\n\r\n  /**\r\n   * Check solution after both tiles have been selected by player\r\n   */\r\n  useEffect(() => {\r\n    if (tile1Coords !== undefined && tile2Coords !== undefined) {\r\n      const tile1 = gameField[tile1Coords.y][tile1Coords.x];\r\n      const tile2 = gameField[tile2Coords.y][tile2Coords.x];\r\n\r\n      const isSolved =\r\n        tile1.cardType === tile2.cardType &&\r\n        canCrossTiles(tile1Coords, tile2Coords);\r\n\r\n      setTimeout(() => {\r\n        unsetSelectedTiles(isSolved);\r\n        setTile1Coords(undefined);\r\n        setTile2Coords(undefined);\r\n        setShowHint(false);\r\n      }, 500);\r\n    }\r\n  }, [tile1Coords, tile2Coords]);\r\n\r\n  /**\r\n   * Finds all tile couples on given fields and returns first solution as an array of coordinates of two tiles.\r\n   *\r\n   * @param gameField\r\n   * @returns\r\n   */\r\n  const getExistingSolutions = (gameField: GameField) => {\r\n    for (let cardType = 0; cardType < POKEMON_COUNT; cardType++) {\r\n      const coords: Coords[] = [];\r\n      gameField.forEach((row, y) => {\r\n        row.forEach((card, x) => {\r\n          if (card.cardType === cardType && !card.isSolved) {\r\n            coords.push({ x, y });\r\n          }\r\n        });\r\n      });\r\n      for (let coordA = 0; coordA < coords.length - 1; coordA++) {\r\n        for (let coordB = coordA + 1; coordB < coords.length; coordB++) {\r\n          if (canCrossTiles(coords[coordA], coords[coordB])) {\r\n            return [coords[coordA], coords[coordB]];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n\r\n  /**\r\n   * Returns new version of the given field by reshuffling existing tiles. Used when player has no solutions available.\r\n   *\r\n   * @param gameField GameField object composed of rows and tiles inside them\r\n   * @returns\r\n   */\r\n  const getReshuffledField = (gameField: GameField) => {\r\n    const typesLeft: number[] = [];\r\n    gameField.forEach((row) =>\r\n      row.forEach((card) => {\r\n        if (!card.isSolved) {\r\n          typesLeft.push(card.cardType);\r\n        }\r\n      })\r\n    );\r\n\r\n    const newGameField = gameField.map((row) =>\r\n      row.map((card) => ({\r\n        cardType: !card.isSolved\r\n          ? typesLeft.splice(Math.floor(Math.random() * typesLeft.length), 1)[0]\r\n          : card.cardType,\r\n        isSelected: false,\r\n        isSolved: card.isSolved,\r\n      }))\r\n    );\r\n\r\n    return newGameField;\r\n  };\r\n\r\n  /**\r\n   * Initial hint preparation\r\n   */\r\n  useEffect(() => {\r\n    setExistingSolution(getExistingSolutions(gameField));\r\n  }, []);\r\n\r\n  /**\r\n   * Show two tiles that could be solved. Untoggles once player selects both of them.\r\n   */\r\n  const onShowHint = () => {\r\n    setShowHint(true);\r\n  };\r\n\r\n  return {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    couplesFound,\r\n  };\r\n};\r\n","import { DIMENSIONS_X, DIMENSIONS_Y } from \"../hooks/useGameField\";\r\nimport { FieldTile as FieldTileType } from \"../types/GameField\";\r\n\r\ntype FieldTileProps = FieldTileType & {\r\n  onClick: () => void;\r\n  highlighted: boolean;\r\n};\r\n\r\nconst FieldTile: React.FC<FieldTileProps> = ({\r\n  cardType,\r\n  isSelected,\r\n  isSolved,\r\n  onClick,\r\n  highlighted,\r\n}) => {\r\n  const tileSize = Math.min(\r\n    Math.floor(\r\n      Math.min(\r\n        (window.innerWidth - DIMENSIONS_X * 4) / DIMENSIONS_X,\r\n        window.innerHeight / DIMENSIONS_Y\r\n      )\r\n    ),\r\n    60\r\n  );\r\n  const spriteX = Math.floor(cardType % 6) * tileSize;\r\n  const spriteY = Math.floor(cardType / 6) * tileSize;\r\n\r\n  const getColor = (\r\n    selectedColor: string,\r\n    normalColor: string,\r\n    highlightedColor: string\r\n  ) => {\r\n    if (isSolved) {\r\n      return \"transparent\";\r\n    }\r\n    if (isSelected) {\r\n      return selectedColor;\r\n    }\r\n    if (highlighted) {\r\n      return highlightedColor;\r\n    }\r\n\r\n    return normalColor;\r\n  };\r\n\r\n  const backgroundColor = getColor(\"#B5DDE5\", \"#FFFFDB\", \"red\");\r\n  const darkBorderColor = getColor(\"#566F81\", \"#817C56\", \"red\");\r\n  const lightBorderColor = getColor(\"#D2F7FF\", \"#E9E3B9\", \"red\");\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width: tileSize + \"px\",\r\n        height: tileSize + \"px\",\r\n        backgroundImage: isSolved\r\n          ? undefined\r\n          : `url(${process.env.PUBLIC_URL}/sprites.png)`,\r\n        backgroundColor,\r\n        backgroundPosition: `${spriteX}px ${spriteY}px`,\r\n        backgroundSize: `${360 * (tileSize / 60)}px`,\r\n        borderTop: \"2px solid \" + darkBorderColor,\r\n        borderRight: \"2px solid \" + darkBorderColor,\r\n        borderBottom: \"2px solid \" + lightBorderColor,\r\n        borderLeft: \"2px solid \" + lightBorderColor,\r\n        cursor: isSolved ? \"default\" : \"pointer\",\r\n      }}\r\n      onClick={() => onClick()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default FieldTile;\r\n","type WinModalProps = {\r\n  onOk: () => void;\r\n  show: boolean;\r\n};\r\n\r\nconst WinModal: React.FC<WinModalProps> = ({ onOk, show }) => {\r\n  return (\r\n    <div\r\n      style={{\r\n        backgroundColor: \"rgba(0, 0, 0, .4)\",\r\n        position: \"absolute\",\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n        zIndex: 10,\r\n        left: 0,\r\n        top: 0,\r\n        display: show ? \"flex\" : \"none\",\r\n        alignItems: \"center\",\r\n        justifyContent: \"center\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          backgroundColor: \"#FFF\",\r\n          padding: \"16px\",\r\n        }}\r\n      >\r\n        <h2>Congratulations!</h2>\r\n        <p>\r\n          There are no further levels at this point but you can replay the first\r\n          level again :)\r\n        </p>\r\n        <button onClick={onOk}>Great</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WinModal;\r\n","import \"./styles.css\";\r\nimport FieldTile from \"./components/FieldTile\";\r\nimport { useGameField } from \"./hooks/useGameField\";\r\nimport { useState } from \"react\";\r\nimport WinModal from \"./components/WinModal\";\r\n\r\nexport default function App() {\r\n  const {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    couplesFound,\r\n  } = useGameField(() => {\r\n    setHasWon(true);\r\n  });\r\n\r\n  const [hasWon, setHasWon] = useState(false);\r\n\r\n  return (\r\n    <div\r\n      className=\"App\"\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        height: \"100vh\",\r\n        margin: \"0 auto\",\r\n        maxWidth: \"1024px\",\r\n        flexDirection: \"column\",\r\n        caretColor: \"transparent\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          width: \"100%\",\r\n          display: \"flex\",\r\n          alignItems: \"center\",\r\n          justifyContent: \"space-between\",\r\n        }}\r\n      >\r\n        <h1 style={{ color: \"white\" }}>PaoPao {couplesFound}/72</h1>\r\n        <button onClick={onShowHint}>Show hint</button>\r\n      </div>\r\n      <div>\r\n        {gameField.map((row, y) => (\r\n          <div\r\n            key={`row-${y}`}\r\n            style={{\r\n              display: \"flex\",\r\n            }}\r\n          >\r\n            {row.map((card, x) => (\r\n              <FieldTile\r\n                highlighted={\r\n                  showHint && existingSolution\r\n                    ? existingSolution?.some(\r\n                        (coord) => coord.x === x && coord.y === y\r\n                      )\r\n                    : false\r\n                }\r\n                {...card}\r\n                key={`card-${x}-${y}-${card.cardType}`}\r\n                onClick={() => selectFieldTile(x, y)}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n      <WinModal show={hasWon} onOk={() => setHasWon(false)} />\r\n    </div>\r\n  );\r\n}\r\n","import { StrictMode } from \"react\";\r\nimport * as ReactDOMClient from \"react-dom/client\";\r\nimport { register as registerServiceWorker } from \"./serviceWorkerRegistration\";\r\n\r\nimport App from \"./App\";\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nconst root = ReactDOMClient.createRoot(rootElement);\r\n\r\nroot.render(\r\n  <StrictMode>\r\n    <App />\r\n  </StrictMode>\r\n);\r\n\r\nregisterServiceWorker();\r\n"],"sourceRoot":""}
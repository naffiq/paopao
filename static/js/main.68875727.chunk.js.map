{"version":3,"sources":["serviceWorkerRegistration.ts","types/GameField.ts","hooks/useGameField.ts","components/FieldTile.tsx","components/WinModal.tsx","App.tsx","index.tsx"],"names":["isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","Directions","DIMENSIONS_Y","outerWidth","outerHeight","DIMENSIONS_X","FIELD_STORAGE_KEY","generateMap","cardTypes","Array","fill","map","_","i","Math","floor","cardType","splice","random","length","isSolved","isSelected","storedFieldString","localStorage","getItem","initialField","JSON","parse","useGameField","onWin","useState","gameField","setGameField","showHint","setShowHint","count","forEach","row","card","countSolvedTiles","couplesFound","setCouplesFound","undefined","tile1Coords","setTile1Coords","tile2Coords","setTile2Coords","existingSolution","setExistingSolution","setFieldSelected","x","y","newTile","updatedRow","oldTile","oldRow","j","updateFieldTile","canCrossTiles","x1","y1","x2","y2","paths","drawPath","direction","turns","Initial","getDirectionIncrement","newDirection","Left","Right","Up","Down","useEffect","tile1","tile2","setTimeout","updatedField","fieldRow","fieldTile","updatedSolution","getExistingSolutions","getReshuffledField","setItem","stringify","unsetSelectedTiles","coords","push","coordA","coordB","typesLeft","selectFieldTile","tile","onShowHint","FieldTile","onClick","highlighted","tileSize","min","innerWidth","innerHeight","spriteX","spriteY","getColor","selectedColor","normalColor","highlightedColor","backgroundColor","darkBorderColor","lightBorderColor","style","width","height","backgroundImage","process","backgroundPosition","backgroundSize","borderTop","borderRight","borderBottom","borderLeft","cursor","WinModal","onOk","show","position","zIndex","left","top","display","alignItems","justifyContent","padding","App","setHasWon","hasWon","className","margin","maxWidth","flexDirection","caretColor","color","some","coord","key","rootElement","document","getElementById","ReactDOMClient","render","URL","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.68875727.chunk.js","sourcesContent":["const isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config?: any) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://cra.link/PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: any, config: any) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://cra.link/PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: any, config: any) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","export type CardType = number;\r\n\r\nexport type FieldTile = {\r\n  cardType: CardType;\r\n  isSolved: boolean;\r\n  isSelected: boolean;\r\n};\r\n\r\nexport type FieldRow = Array<FieldTile>;\r\n\r\nexport type GameField = Array<FieldRow>;\r\n\r\nexport enum Directions {\r\n  Initial,\r\n  Up,\r\n  Down,\r\n  Left,\r\n  Right,\r\n}\r\n","import { useEffect, useState } from \"react\";\nimport { FieldTile, GameField, Directions } from \"../types/GameField\";\n\nexport const DIMENSIONS_Y = window.outerWidth > window.outerHeight ? 9 : 16;\nexport const DIMENSIONS_X = window.outerWidth > window.outerHeight ? 16 : 9;\nconst POKEMON_COUNT = 36;\nconst FIELD_STORAGE_KEY = \"paopao-field\";\n\ntype Coords = {\n  x: number;\n  y: number;\n};\n\nconst generateMap: () => GameField = () => {\n  const cardTypes = new Array(DIMENSIONS_X * DIMENSIONS_Y)\n    .fill(null)\n    .map((_, i) => Math.floor(i / 4));\n\n  return new Array(DIMENSIONS_Y).fill(null).map(() =>\n    new Array(DIMENSIONS_X).fill(null).map(() => ({\n      cardType: cardTypes.splice(\n        Math.floor(Math.random() * cardTypes.length),\n        1\n      )[0],\n      isSolved: false,\n      isSelected: false,\n    }))\n  );\n};\n\nconst storedFieldString = localStorage.getItem(FIELD_STORAGE_KEY);\nconst initialField =\n  storedFieldString !== null ? JSON.parse(storedFieldString) : generateMap();\n\nconst countSolvedTiles = (gameField: GameField) => {\n  let count = 0;\n  gameField.forEach((row) =>\n    row.forEach((card) => (count += card.isSolved ? 1 : 0))\n  );\n  return count / 2;\n};\n\nexport const useGameField = (onWin: () => void) => {\n  const [gameField, setGameField] = useState<GameField>(initialField);\n  const [showHint, setShowHint] = useState(false);\n  const [couplesFound, setCouplesFound] = useState(\n    countSolvedTiles(initialField)\n  );\n\n  const [tile1Coords, setTile1Coords] = useState<Coords | undefined>(undefined);\n  const [tile2Coords, setTile2Coords] = useState<Coords | undefined>(undefined);\n  const [existingSolution, setExistingSolution] = useState<\n    Coords[] | undefined\n  >();\n\n  const updateFieldTile = (x: number, y: number, newTile: FieldTile) => {\n    const updatedRow = gameField[y].map((oldTile, i) =>\n      i === x ? newTile : oldTile\n    );\n    setGameField(gameField.map((oldRow, j) => (j === y ? updatedRow : oldRow)));\n  };\n\n  /**\n   *\n   * @param x\n   * @param y\n   * @param isSelected\n   */\n  const setFieldSelected = (x: number, y: number, isSelected: boolean) => {\n    updateFieldTile(x, y, {\n      ...gameField[y][x],\n      isSelected,\n    });\n  };\n\n  /**\n   * Checks if the tile can be selected and updates the state of the board\n   *\n   * @param x coordinates of the field\n   * @param y coordinates of the field\n   * @returns\n   */\n  const selectFieldTile = (x: number, y: number) => {\n    const tile = gameField[y][x];\n    if (tile.isSolved || tile.isSelected) {\n      return;\n    }\n\n    if (tile1Coords === undefined) {\n      setFieldSelected(x, y, true);\n      setTile1Coords({ x, y });\n    } else if (tile2Coords === undefined) {\n      setFieldSelected(x, y, true);\n      setTile2Coords({ x, y });\n    }\n  };\n\n  /**\n   * Updates the field and removes selection of tiles. If `isSolved === true` then hides the tiles.\n   * If the resulted field does not have any solutions it will be reshuffled until one was found.\n   *\n   * @param isSolved\n   */\n  const unsetSelectedTiles = (isSolved: boolean) => {\n    let updatedField = gameField.map((fieldRow) =>\n      fieldRow.map((fieldTile) =>\n        fieldTile.isSelected\n          ? {\n              ...fieldTile,\n              isSelected: false,\n              isSolved,\n            }\n          : fieldTile\n      )\n    );\n    if (isSolved) {\n      setCouplesFound(couplesFound + 1);\n\n      if (couplesFound === (DIMENSIONS_X * DIMENSIONS_Y) / 2 - 1) {\n        updatedField = generateMap();\n        setCouplesFound(0);\n        onWin();\n      }\n      let updatedSolution = getExistingSolutions(updatedField);\n\n      while (updatedSolution === undefined) {\n        updatedField = getReshuffledField(updatedField);\n        updatedSolution = getExistingSolutions(updatedField);\n      }\n      setExistingSolution(updatedSolution);\n    }\n\n    setGameField(updatedField);\n    localStorage.setItem(FIELD_STORAGE_KEY, JSON.stringify(updatedField));\n  };\n\n  /**\n   * Check if tiles can be solved by finding the shortest path between them in terms of turns to be ma\n   * @param gameField   The data with game pointsde.\n   * @param tile1Coords Coordinates of the first tile on the field in the state\n   * @param tile2Coords Coordinates of the second tile on the field in the state\n   * @returns\n   */\n  const canCrossTiles = (\n gameField: GameField,\n    { x: x1, y: y1 }: Coords,\n    { x: x2, y: y2 }: Coords\n  ) => {\n    // Initialize paths from first tiles as infinity (or close) with extra space for path finding\n    const paths = new Array(DIMENSIONS_Y + 1)\n      .fill(null)\n      .map(() => new Array(DIMENSIONS_X).fill(999));\n    // Add outer dimension to the paths as the paths can go outside of the field\n    paths[-1] = new Array(DIMENSIONS_X).fill(999);\n\n    /**\n     * Crawls through adjacent tiles recursively and updates closest paths if possible\n     *\n     * @param direction   Initial direction of the movement. Each change of the direction increases\n     * @param x           coordinates of the tile in current iteration\n     * @param y           coordinates of the tile in current iteration\n     * @param turns       number of turns made to reach the tile\n     * @void           the function updates `paths` array and does not return anything\n     */\n    const drawPath = (\n      direction: Directions,\n      x: number,\n      y: number,\n      turns: number\n    ) => {\n      // break the function execution\n      if (turns > 2 || paths[y][x] < turns) {\n        return;\n      }\n      paths[y][x] = turns;\n      if (x == x2 && y == y2) {\n        return;\n      }\n\n      if (\n        gameField[y] &&\n        gameField[y][x] &&\n        !gameField[y][x].isSolved &&\n        direction !== Directions.Initial\n      ) {\n        return;\n      }\n\n      if (paths[y2][x2] <= 2) {\n        return;\n      }\n\n      const getDirectionIncrement = (newDirection: Directions) =>\n        direction !== newDirection && direction !== Directions.Initial ? 1 : 0;\n\n      if (x > -1) {\n        drawPath(\n          Directions.Left,\n          x - 1,\n          y,\n          turns + getDirectionIncrement(Directions.Left)\n        );\n      }\n\n      if (x < DIMENSIONS_X) {\n        drawPath(\n          Directions.Right,\n          x + 1,\n          y,\n          turns + getDirectionIncrement(Directions.Right)\n        );\n      }\n\n      if (y > -1) {\n        drawPath(\n          Directions.Up,\n          x,\n          y - 1,\n          turns + getDirectionIncrement(Directions.Up)\n        );\n      }\n\n      if (y < DIMENSIONS_Y) {\n        drawPath(\n          Directions.Down,\n          x,\n          y + 1,\n          turns + getDirectionIncrement(Directions.Down)\n        );\n      }\n    };\n\n    drawPath(Directions.Initial, x1, y1, 0);\n\n    return paths[y2][x2] <= 2;\n  };\n\n  /**\n   * Check solution after both tiles have been selected by player\n   */\n  useEffect(() => {\n    if (tile1Coords !== undefined && tile2Coords !== undefined) {\n      const tile1 = gameField[tile1Coords.y][tile1Coords.x];\n      const tile2 = gameField[tile2Coords.y][tile2Coords.x];\n\n      const isSolved =\n        tile1.cardType === tile2.cardType &&\n        canCrossTiles(gameField, tile1Coords, tile2Coords);\n\n      setTimeout(() => {\n        unsetSelectedTiles(isSolved);\n        setTile1Coords(undefined);\n        setTile2Coords(undefined);\n        setShowHint(false);\n      }, 500);\n    }\n  }, [tile1Coords, tile2Coords]);\n\n  /**\n   * Finds all tile couples on given fields and returns first solution as an array of coordinates of two tiles.\n   *\n   * @param gameField\n   * @returns\n   */\n  const getExistingSolutions = (gameField: GameField) => {\n    for (let cardType = 0; cardType < POKEMON_COUNT; cardType++) {\n      const coords: Coords[] = [];\n      gameField.forEach((row, y) => {\n        row.forEach((card, x) => {\n          if (card.cardType === cardType && !card.isSolved) {\n            coords.push({ x, y });\n          }\n        });\n      });\n      for (let coordA = 0; coordA < coords.length - 1; coordA++) {\n        for (let coordB = coordA + 1; coordB < coords.length; coordB++) {\n          if (canCrossTiles(gameField, coords[coordA], coords[coordB])) {\n            return [coords[coordA], coords[coordB]];\n          }\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  /**\n   * Returns new version of the given field by reshuffling existing tiles. Used when player has no solutions available.\n   *\n   * @param gameField GameField object composed of rows and tiles inside them\n   * @returns\n   */\n  const getReshuffledField = (gameField: GameField) => {\n    const typesLeft: number[] = [];\n    gameField.forEach((row) =>\n      row.forEach((card) => {\n        if (!card.isSolved) {\n          typesLeft.push(card.cardType);\n        }\n      })\n    );\n\n    const newGameField = gameField.map((row) =>\n      row.map((card) => ({\n        cardType: !card.isSolved\n          ? typesLeft.splice(Math.floor(Math.random() * typesLeft.length), 1)[0]\n          : card.cardType,\n        isSelected: false,\n        isSolved: card.isSolved,\n      }))\n    );\n\n    return newGameField;\n  };\n\n  /**\n   * Initial hint preparation\n   */\n  useEffect(() => {\n    setExistingSolution(getExistingSolutions(gameField));\n  }, []);\n\n  /**\n   * Show two tiles that could be solved. Untoggles once player selects both of them.\n   */\n  const onShowHint = () => {\n    setShowHint(true);\n  };\n\n  return {\n    gameField,\n    selectFieldTile,\n    existingSolution,\n    onShowHint,\n    showHint,\n    couplesFound,\n  };\n};\n","import { DIMENSIONS_X, DIMENSIONS_Y } from \"../hooks/useGameField\";\nimport { FieldTile as FieldTileType } from \"../types/GameField\";\n\ntype FieldTileProps = FieldTileType & {\n  onClick: () => void;\n  highlighted: boolean;\n};\n\nconst FieldTile: React.FC<FieldTileProps> = ({\n  cardType,\n  isSelected,\n  isSolved,\n  onClick,\n  highlighted,\n}) => {\n  const tileSize = Math.min(\n    Math.floor(\n      Math.min(\n        (window.innerWidth - DIMENSIONS_X * 4) / DIMENSIONS_X,\n        window.innerHeight / DIMENSIONS_Y\n      )\n    ),\n    60\n  );\n  const spriteX = Math.floor(cardType % 6) * tileSize;\n  const spriteY = Math.floor(cardType / 6) * tileSize;\n\n  const getColor = (\n    selectedColor: string,\n    normalColor: string,\n    highlightedColor: string\n  ) => {\n    if (isSolved) {\n      return \"transparent\";\n    }\n    if (isSelected) {\n      return selectedColor;\n    }\n    if (highlighted) {\n      return highlightedColor;\n    }\n\n    return normalColor;\n  };\n\n  const backgroundColor = getColor(\"#B5DDE5\", \"#FFFFDB\", \"red\");\n  const darkBorderColor = getColor(\"#566F81\", \"#817C56\", \"red\");\n  const lightBorderColor = getColor(\"#D2F7FF\", \"#E9E3B9\", \"red\");\n\n  return (\n    <div\n      style={{\n        width: tileSize + \"px\",\n        height: tileSize + \"px\",\n        backgroundImage: isSolved\n          ? undefined\n          : `url(${process.env.PUBLIC_URL}/sprites.png)`,\n        backgroundColor,\n        backgroundPosition: `${spriteX}px ${spriteY}px`,\n        backgroundSize: `${360 * (tileSize / 60)}px`,\n        borderTop: \"2px solid \" + darkBorderColor,\n        borderRight: \"2px solid \" + darkBorderColor,\n        borderBottom: \"2px solid \" + lightBorderColor,\n        borderLeft: \"2px solid \" + lightBorderColor,\n        cursor: isSolved ? \"default\" : \"pointer\",\n      }}\n      onClick={() => onClick()}\n    ></div>\n  );\n};\n\nexport default FieldTile;\n","type WinModalProps = {\n  onOk: () => void;\n  show: boolean;\n};\n\nconst WinModal: React.FC<WinModalProps> = ({ onOk, show }) => {\n  return (\n    <div\n      style={{\n        backgroundColor: \"rgba(0, 0, 0, .4)\",\n        position: \"absolute\",\n        width: \"100vw\",\n        height: \"100vh\",\n        zIndex: 10,\n        left: 0,\n        top: 0,\n        display: show ? \"flex\" : \"none\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n      }}\n    >\n      <div\n        style={{\n          backgroundColor: \"#FFF\",\n          padding: \"16px\",\n        }}\n      >\n        <h2>Congratulations!</h2>\n        <p>\n          There are no further levels at this point but you can replay the first\n          level again :)\n        </p>\n        <button onClick={onOk}>Great</button>\n      </div>\n    </div>\n  );\n};\n\nexport default WinModal;\n","import \"./styles.css\";\nimport FieldTile from \"./components/FieldTile\";\nimport { useGameField } from \"./hooks/useGameField\";\nimport { useState } from \"react\";\nimport WinModal from \"./components/WinModal\";\n\nexport default function App() {\n  const {\n    gameField,\n    selectFieldTile,\n    existingSolution,\n    onShowHint,\n    showHint,\n    couplesFound,\n  } = useGameField(() => {\n    setHasWon(true);\n  });\n\n  const [hasWon, setHasWon] = useState(false);\n\n  return (\n    <div\n      className=\"App\"\n      style={{\n        display: \"flex\",\n        justifyContent: \"center\",\n        alignItems: \"center\",\n        height: \"100vh\",\n        margin: \"0 auto\",\n        maxWidth: \"1024px\",\n        flexDirection: \"column\",\n        caretColor: \"transparent\",\n      }}\n    >\n      <div\n        style={{\n          width: \"100%\",\n          display: \"flex\",\n          alignItems: \"center\",\n          justifyContent: \"space-between\",\n        }}\n      >\n        <h1 style={{ color: \"white\" }}>PaoPao {couplesFound}/72</h1>\n        <button onClick={onShowHint}>Show hint</button>\n      </div>\n      <div>\n        {gameField.map((row, y) => (\n          <div\n            key={`row-${y}`}\n            style={{\n              display: \"flex\",\n            }}\n          >\n            {row.map((card, x) => (\n              <FieldTile\n                highlighted={\n                  showHint && existingSolution\n                    ? existingSolution?.some(\n                        (coord) => coord.x === x && coord.y === y\n                      )\n                    : false\n                }\n                {...card}\n                key={`card-${x}-${y}-${card.cardType}`}\n                onClick={() => selectFieldTile(x, y)}\n              />\n            ))}\n          </div>\n        ))}\n      </div>\n      <WinModal show={hasWon} onOk={() => setHasWon(false)} />\n    </div>\n  );\n}\n","import { StrictMode } from \"react\";\nimport * as ReactDOMClient from \"react-dom/client\";\nimport { register as registerServiceWorker } from \"./serviceWorkerRegistration\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nconst root = ReactDOMClient.createRoot(rootElement);\n\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n\nregisterServiceWorker();\n"],"sourceRoot":""}
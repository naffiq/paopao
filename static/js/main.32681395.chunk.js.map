{"version":3,"sources":["FieldTile.tsx","hooks/useGameField.ts","App.tsx","index.tsx"],"names":["FieldTile","props","spriteX","Math","floor","cardType","spriteY","getColor","selectedColor","normalColor","highlightedColor","console","log","isSolved","isSelected","highlighted","backgroundColor","darkBorderColor","lightBorderColor","style","width","height","background","undefined","process","borderTop","borderRight","borderBottom","borderLeft","onClick","useGameField","useState","cardTypes","Array","DIMENSIONS_X","fill","map","_","i","splice","random","length","generateMap","gameField","setGameField","showHint","setShowHint","tile1Coords","setTile1Coords","tile2Coords","setTile2Coords","existingSolution","setExistingSolution","setFieldSelected","x","y","newTile","updatedRow","oldTile","oldRow","j","updateFieldTile","canCrossTiles","Directions","x1","y1","x2","y2","paths","DIMENSIONS_Y","drawPath","direction","turns","Initial","getDirectionIncrement","newDirection","Left","Right","Up","Down","useEffect","tile1","tile2","setTimeout","updatedField","fieldRow","fieldTile","updatedSolution","getExistingSolutions","getReshuffledField","unsetSelectedTiles","coords","forEach","row","card","push","coordA","coordB","typesLeft","newGameField","selectFieldTile","tile","onShowHint","onFieldShuffle","App","className","display","justifyContent","alignItems","maxWidth","flexDirection","caretColor","some","coord","key","rootElement","document","getElementById","ReactDOMClient","render"],"mappings":"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","file":"static/js/main.32681395.chunk.js","sourcesContent":["import { FieldTile as FieldTileType } from \"./types/GameField\";\r\n\r\ntype FieldTileProps = FieldTileType & {\r\n  onClick: () => void;\r\n  highlighted: boolean;\r\n};\r\n\r\nconst FieldTile: React.FC<FieldTileProps> = (props) => {\r\n  const spriteX = Math.floor(props.cardType % 6) * 60;\r\n  const spriteY = Math.floor(props.cardType / 6) * 60;\r\n\r\n  const getColor = (\r\n    selectedColor: string,\r\n    normalColor: string,\r\n    highlightedColor: string\r\n  ) => {\r\n    console.log(props);\r\n    if (props.isSolved) {\r\n      return \"transparent\";\r\n    }\r\n    if (props.isSelected) {\r\n      return selectedColor;\r\n    }\r\n    if (props.highlighted) {\r\n      return highlightedColor;\r\n    }\r\n\r\n    return normalColor;\r\n  };\r\n\r\n  const backgroundColor = getColor(\"#B5DDE5\", \"#FFFFDB\", \"red\");\r\n  const darkBorderColor = getColor(\"#566F81\", \"#817C56\", \"red\");\r\n  const lightBorderColor = getColor(\"#D2F7FF\", \"#E9E3B9\", \"red\");\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width: \"60px\",\r\n        height: \"60px\",\r\n        background: props.isSolved\r\n          ? undefined\r\n          : `url(${process.env.PUBLIC_URL}/sprites.png) ${spriteX}px ${spriteY}px`,\r\n        backgroundColor,\r\n        borderTop: \"1px solid \" + darkBorderColor,\r\n        borderRight: \"1px solid \" + darkBorderColor,\r\n        borderBottom: \"1px solid \" + lightBorderColor,\r\n        borderLeft: \"1px solid \" + lightBorderColor,\r\n      }}\r\n      onClick={() => props.onClick()}\r\n    ></div>\r\n  );\r\n};\r\n\r\nexport default FieldTile;\r\n","import { useEffect, useState } from \"react\";\r\nimport { FieldTile, GameField } from \"../types/GameField\";\r\n\r\nconst DIMENSIONS_Y = 9;\r\nconst DIMENSIONS_X = 16;\r\nconst POKEMON_COUNT = 36;\r\n\r\ntype Coords = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\nconst generateMap: () => GameField = () => {\r\n  const cardTypes = new Array(DIMENSIONS_X * DIMENSIONS_Y)\r\n    .fill(null)\r\n    .map((_, i) => Math.floor(i / 4));\r\n\r\n  return new Array(DIMENSIONS_Y).fill(null).map(() =>\r\n    new Array(DIMENSIONS_X).fill(null).map(() => ({\r\n      cardType: cardTypes.splice(\r\n        Math.floor(Math.random() * cardTypes.length),\r\n        1\r\n      )[0],\r\n      isSolved: false,\r\n      isSelected: false,\r\n    }))\r\n  );\r\n};\r\n\r\nexport const useGameField = () => {\r\n  const [gameField, setGameField] = useState<GameField>(generateMap());\r\n  const [showHint, setShowHint] = useState(false);\r\n\r\n  const [tile1Coords, setTile1Coords] = useState<Coords | undefined>(undefined);\r\n  const [tile2Coords, setTile2Coords] = useState<Coords | undefined>(undefined);\r\n  const [existingSolution, setExistingSolution] = useState<\r\n    Coords[] | undefined\r\n  >();\r\n\r\n  const updateFieldTile = (x: number, y: number, newTile: FieldTile) => {\r\n    const updatedRow = gameField[y].map((oldTile, i) =>\r\n      i === x ? newTile : oldTile\r\n    );\r\n    setGameField(gameField.map((oldRow, j) => (j === y ? updatedRow : oldRow)));\r\n  };\r\n  const setFieldSelected = (x: number, y: number, isSelected: boolean) => {\r\n    updateFieldTile(x, y, {\r\n      ...gameField[y][x],\r\n      isSelected,\r\n    });\r\n  };\r\n\r\n  const selectFieldTile = (x: number, y: number) => {\r\n    const tile = gameField[y][x];\r\n    if (tile.isSolved || tile.isSelected) {\r\n      return;\r\n    }\r\n\r\n    if (tile1Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile1Coords({ x, y });\r\n    } else if (tile2Coords === undefined) {\r\n      setFieldSelected(x, y, true);\r\n      setTile2Coords({ x, y });\r\n    } else {\r\n    }\r\n  };\r\n\r\n  const unsetSelectedTiles = (isSolved: boolean) => {\r\n    let updatedField = gameField.map((fieldRow) =>\r\n      fieldRow.map((fieldTile) =>\r\n        fieldTile.isSelected\r\n          ? {\r\n              ...fieldTile,\r\n              isSelected: false,\r\n              isSolved,\r\n            }\r\n          : fieldTile\r\n      )\r\n    );\r\n    if (isSolved) {\r\n      let updatedSolution = getExistingSolutions(updatedField);\r\n\r\n      while (updatedSolution === undefined) {\r\n        updatedField = getReshuffledField(updatedField);\r\n        updatedSolution = getExistingSolutions(updatedField);\r\n      }\r\n      setExistingSolution(updatedSolution);\r\n    }\r\n\r\n    setGameField(updatedField);\r\n  };\r\n\r\n  const canCrossTiles = (\r\n    { x: x1, y: y1 }: Coords,\r\n    { x: x2, y: y2 }: Coords\r\n  ) => {\r\n    const paths = new Array(DIMENSIONS_Y + 1)\r\n      .fill(null)\r\n      .map(() => new Array(DIMENSIONS_X).fill(999));\r\n    paths[-1] = new Array(DIMENSIONS_X).fill(999);\r\n\r\n    enum Directions {\r\n      Initial,\r\n      Up,\r\n      Down,\r\n      Left,\r\n      Right,\r\n    }\r\n    const drawPath = (\r\n      direction: Directions,\r\n      x: number,\r\n      y: number,\r\n      turns: number\r\n    ) => {\r\n      if (turns > 2 || paths[y][x] < turns) {\r\n        return;\r\n      }\r\n      paths[y][x] = turns;\r\n      if (x == x2 && y == y2) {\r\n        return;\r\n      }\r\n\r\n      if (\r\n        gameField[y] &&\r\n        gameField[y][x] &&\r\n        !gameField[y][x].isSolved &&\r\n        direction !== Directions.Initial\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      if (paths[y2][x2] <= 2) {\r\n        return;\r\n      }\r\n\r\n      const getDirectionIncrement = (newDirection: Directions) =>\r\n        direction !== newDirection && direction !== Directions.Initial ? 1 : 0;\r\n\r\n      if (x > -1) {\r\n        drawPath(\r\n          Directions.Left,\r\n          x - 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Left)\r\n        );\r\n      }\r\n\r\n      if (x < DIMENSIONS_X) {\r\n        drawPath(\r\n          Directions.Right,\r\n          x + 1,\r\n          y,\r\n          turns + getDirectionIncrement(Directions.Right)\r\n        );\r\n      }\r\n\r\n      if (y > -1) {\r\n        drawPath(\r\n          Directions.Up,\r\n          x,\r\n          y - 1,\r\n          turns + getDirectionIncrement(Directions.Up)\r\n        );\r\n      }\r\n\r\n      if (y < DIMENSIONS_Y) {\r\n        drawPath(\r\n          Directions.Down,\r\n          x,\r\n          y + 1,\r\n          turns + getDirectionIncrement(Directions.Down)\r\n        );\r\n      }\r\n    };\r\n\r\n    drawPath(Directions.Initial, x1, y1, 0);\r\n\r\n    return paths[y2][x2] <= 2;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (tile1Coords !== undefined && tile2Coords !== undefined) {\r\n      const tile1 = gameField[tile1Coords.y][tile1Coords.x];\r\n      const tile2 = gameField[tile2Coords.y][tile2Coords.x];\r\n\r\n      const isSolved =\r\n        tile1.cardType === tile2.cardType &&\r\n        canCrossTiles(tile1Coords, tile2Coords);\r\n\r\n      setTimeout(() => {\r\n        unsetSelectedTiles(isSolved);\r\n        setTile1Coords(undefined);\r\n        setTile2Coords(undefined);\r\n        setShowHint(false);\r\n      }, 500);\r\n    }\r\n  }, [tile1Coords, tile2Coords]);\r\n\r\n  useEffect(() => {\r\n    console.log(\"existingSolution\", existingSolution);\r\n    if (existingSolution === undefined) {\r\n      console.log(\"TODO: REGENERATE THE MAP\");\r\n    }\r\n  }, [existingSolution]);\r\n\r\n  const getExistingSolutions = (gameField: GameField) => {\r\n    for (let cardType = 0; cardType < POKEMON_COUNT; cardType++) {\r\n      const coords: Coords[] = [];\r\n      gameField.forEach((row, y) => {\r\n        row.forEach((card, x) => {\r\n          if (card.cardType === cardType && !card.isSolved) {\r\n            coords.push({ x, y });\r\n          }\r\n        });\r\n      });\r\n      for (let coordA = 0; coordA < coords.length - 1; coordA++) {\r\n        for (let coordB = coordA + 1; coordB < coords.length; coordB++) {\r\n          if (canCrossTiles(coords[coordA], coords[coordB])) {\r\n            return [coords[coordA], coords[coordB]];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n\r\n  const getReshuffledField = (gameField: GameField) => {\r\n    const typesLeft: number[] = [];\r\n    gameField.forEach((row) =>\r\n      row.forEach((card) => {\r\n        if (!card.isSolved) {\r\n          typesLeft.push(card.cardType);\r\n        }\r\n      })\r\n    );\r\n\r\n    const newGameField = gameField.map((row) =>\r\n      row.map((card) => ({\r\n        cardType: !card.isSolved\r\n          ? typesLeft.splice(Math.floor(Math.random() * typesLeft.length), 1)[0]\r\n          : card.cardType,\r\n        isSelected: false,\r\n        isSolved: card.isSolved,\r\n      }))\r\n    );\r\n\r\n    console.log(newGameField);\r\n\r\n    return newGameField;\r\n  };\r\n\r\n  const onFieldShuffle = () => {\r\n    let updatedField = undefined;\r\n    let updatedSolution = undefined;\r\n    do {\r\n      updatedField = getReshuffledField(gameField);\r\n      updatedSolution = getExistingSolutions(updatedField);\r\n    } while (updatedSolution === undefined);\r\n    setExistingSolution(updatedSolution);\r\n\r\n    setGameField(updatedField);\r\n  };\r\n\r\n  useEffect(() => {\r\n    setExistingSolution(getExistingSolutions(gameField));\r\n  }, []);\r\n\r\n  const onShowHint = () => {\r\n    setShowHint(true);\r\n  };\r\n\r\n  return {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    onFieldShuffle,\r\n  };\r\n};\r\n","import \"./styles.css\";\r\nimport FieldTile from \"./FieldTile\";\r\nimport { useGameField } from \"./hooks/useGameField\";\r\n\r\nexport default function App() {\r\n  const {\r\n    gameField,\r\n    selectFieldTile,\r\n    existingSolution,\r\n    onShowHint,\r\n    showHint,\r\n    onFieldShuffle,\r\n  } = useGameField();\r\n\r\n  return (\r\n    <div\r\n      className=\"App\"\r\n      style={{\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        height: \"100vh\",\r\n        maxWidth: \"1024\",\r\n        flexDirection: \"column\",\r\n        caretColor: \"transparent\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          width: \"100%\",\r\n          display: \"flex\",\r\n          alignItems: \"center\",\r\n          justifyContent: \"space-between\",\r\n        }}\r\n      >\r\n        <h1>\r\n          PaoPao - {existingSolution ? \"Solution exists\" : \"Nah man, give up\"}\r\n        </h1>\r\n        <button onClick={onShowHint}>Show hint</button>\r\n      </div>\r\n      <div>\r\n        {gameField.map((row, y) => (\r\n          <div\r\n            key={`row-${y}`}\r\n            style={{\r\n              display: \"flex\",\r\n            }}\r\n          >\r\n            {row.map((card, x) => (\r\n              <FieldTile\r\n                highlighted={\r\n                  showHint && existingSolution\r\n                    ? existingSolution?.some(\r\n                        (coord) => coord.x === x && coord.y === y\r\n                      )\r\n                    : false\r\n                }\r\n                {...card}\r\n                key={`card-${x}-${y}-${card.cardType}`}\r\n                onClick={() => selectFieldTile(x, y)}\r\n              />\r\n            ))}\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","import { StrictMode } from \"react\";\r\nimport * as ReactDOMClient from \"react-dom/client\";\r\n\r\nimport App from \"./App\";\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nconst root = ReactDOMClient.createRoot(rootElement);\r\n\r\nroot.render(\r\n  <StrictMode>\r\n    <App />\r\n  </StrictMode>\r\n);\r\n"],"sourceRoot":""}